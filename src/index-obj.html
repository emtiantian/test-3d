<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - loaders - OBJ loader</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <style>
    body {
      font-family: Monospace;
      background-color: #000;
      color: #fff;
      margin: 0px;
      overflow: hidden;
    }

    #info {
      color: #fff;
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      z-index: 100;
      display: block;
    }

    #info a,
    .button {
      color: #f00;
      font-weight: bold;
      text-decoration: underline;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <script src="./js/three.js"></script>
  <script src="./js/OrbitControls.js"></script>
  <script src="./js/OBJLoader.js"></script>
  <script src="./js/MTLLoader.js"></script>

  <script>
    // import * as three from 'three';
    var container
    var camera, scene, renderer
    var mouseX = 0,
      mouseY = 0
    var windowHalfX = window.innerWidth / 2
    var windowHalfY = window.innerHeight / 2
    var object
    var clock = new THREE.Clock()
    init()
    animate()

    function init() {
      container = document.createElement('div')
      document.body.appendChild(container)
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        1,
        100000
      )
      camera.position.x = -4000
      camera.position.y = 4000
      camera.position.z = 40000
      // camera.lookAt( new THREE.Vector3(200,300,1000))
      // scene
      scene = new THREE.Scene()
      var ambientLight = new THREE.AmbientLight(0xcccccc, 0.1)
      scene.add(ambientLight)

      var pointLight = new THREE.PointLight(0xffffff, 0.05)
      pointLight.position.set(0,10000,0);
      camera.add(pointLight)

      var hemiLight = new THREE.HemisphereLight(0xffffff, 0xa4a7a8,0.8)
      hemiLight.position.set(0,10000,0);
      scene.add(hemiLight)


      scene.add(camera)
      // manager
      function loadModel() {
        object.traverse(function (child) {
          if (child.isMesh) child.material.map = texture
        })
        object.center();
        //object
        scene.add(object)
      }
      function onError() {}
      // 加载材质及模型
      new THREE.MTLLoader()
        .setPath('./assets/')
        .load('car2.mtl', function (materials) {
          materials.preload()
          new THREE.OBJLoader()
            .setMaterials(materials)
            .setPath('./assets/')
            .load(
              'car2.obj',
              function (object) {
                scene.add(object)
              },
              onProgress,
              onError
            )
        })

      // model
      function onProgress(xhr) {
        if (xhr.lengthComputable) {
          var percentComplete = (xhr.loaded / xhr.total) * 100
          console.log(
            'model ' + Math.round(percentComplete, 2) + '% downloaded'
          )
        }
      }

      renderer = new THREE.WebGLRenderer()
      renderer.setPixelRatio(window.devicePixelRatio)
      renderer.setSize(window.innerWidth, window.innerHeight)
      container.appendChild(renderer.domElement)
      controls = new THREE.OrbitControls(camera, renderer.domElement)
      controls.target.set(0, 0.5, 0)
      controls.enablePan = false
      window.addEventListener('resize', onWindowResize, false)
    }

    function onWindowResize() {
      windowHalfX = window.innerWidth / 2
      windowHalfY = window.innerHeight / 2
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    }

    //
    function animate() {
      requestAnimationFrame(animate)
      render()
    }

    function render() {
      // camera.position.x += (mouseX - camera.position.x) * .05;
      // camera.position.y += (mouseY - camera.position.y) * .05;
      // camera.lookAt(scene.position);
      var delta = clock.getDelta()
      controls.update(delta)
      renderer.render(scene, camera)
    }
  </script>
</body>

</html>